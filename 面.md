1、原型链（一般会聊__prop__）
2、闭包（一般是聊什么是闭包，闭包的作用，什么时候用到）
3、递归算法（一般是树形结构）
4、正则（一般是替换字符串）
5、ES6 里面新的API，Promise
因为我用的是 Vue ，所以：
6、VUE 双向绑定原理
7、Vue 生命周期
8、Vue 路由原理
9、webpack 性能优化（打包太慢，打包的文件太多）
10、开发流程优化
11、跨域
12、CSS3 display:flex有哪些属性，什么含义（必问）
13、CSS3 一些动画和布局问题
14、ajax 原生写法
15、HTTP 协议简单介绍（状态码、请求头如何添加）
16、浏览器缓存原理，如何解决缓存
17、浏览器前端渲染流程
18、排序算法
19、继承写法
20、前端性能优化
1、如果让你做一次轰烈的事情，你会做什么
2、让你刻骨铭心的一个项目是哪个？为什么？
前端安全  xss  csrf攻击

连心医联：
1、跨域
2、变量提升
3、深拷贝浅拷贝
4、数组去重（多种方式）
5、请求（两请求之后执行）
6、原型
7、call()
8、[1,2,3,4,5] => [[1,2,3],[4,5]]


## 知识点梳理
#### 1. 手写事件模型及事件代理/委托
  - 事件的三阶段：捕获，目标，冒泡，低版本IE不支持捕获阶段；
  - 

#### 2. 闭包
  -  广义上的闭包就是指一个变量在他自身作用域外被使用了，就叫发生了闭包；

#### 3. 跨域
- 只要 协议 、 域名 、 端口 有任何一个 不同, 都被当作是 不同 的域。

#### http协议


#### CSS sprites
1. 简介：CSS Sprites在国内很多人叫css精灵，是一种网页图片应用处理方式。它允许将一个页面涉及到的所有零星图片都包含到一张大图中， 利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位， 访问页面时避免图片载入缓慢的现象。
2. 优点：
- CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能，这是CSS Sprites最大的优点，也是其被广泛传播和应用的主要原因；
- CSS Sprites能减少图片的字节；
- CSS Sprites解决了网页设计师在图片命名上的困扰，只需对一张集合的图片命名，不需要对每一个小图片进行命名，从而提高了网页制作效率；
- CSS Sprites只需要修改一张或少张图片的颜色或样式来改变整个网页的风格；
3. 缺点：
- 图片合并麻烦：图片合并时，需要把多张图片有序的合理的合并成一张图片，并留好足够的空间防止版块出现不必要的背景；
- 图片适应性差：在高分辨的屏幕下自适应页面，若图片不够宽会出现背景断裂；
- 图片定位繁琐：开发时需要通过工具测量计算每个背景单元的精确位置；
- 可维护性差：页面背景需要少许改动，可能要修改部分或整张已合并的图片，进而要改动css。在避免改动图片的前提下，又只能（最好）往下追加图片，但这样增加了图片字节；

#### iframe
1. 场景使用：
- 典型系统结构，左侧是功能树，右侧就是一些常见的table或者表单之类的。为了每一个功能，单独分离出来，采用iframe；
- ajax上传文件；
- 加载别的网站内容，例如google广告，网站流量分析；
- 在上传图片时，不用flash实现无刷新；
- 跨域访问的时候可以用到iframe，使用iframe请求不同域名下的资源；



## 知识点对比区分
#### 1. border: none; border: 0
1. 效果：
- border-style: none;  //无边框
- border-width: 0;     //边框宽度为0px
2. 区别：
- 性能差异
```
tips: 请始终把border-style属性声明到border-color属性之前，元素必须在改变颜色之前获得边框;
border:0; //浏览器对border-width、border-color进行渲染，占用内存。
border:none; //浏览器不进行渲染，不占用内存。
rest: border: none; 並不意味着 border: 0; 但反過來可以。
```
- 浏览器兼容性: IE7-不支持 border:none;

#### 2. 伪类、伪元素
- css伪类用于向某些选择器添加特殊的效果；
- css伪元素用于将特殊的效果添加到某些选择器；
1. 伪类种类
:active         将样式添加到被激活的元素
:focus          将样式添加到被选中的元素
:hover          当鼠标悬浮在元素上方时，向元素添加样式
:link           将特殊的样式添加到未被访问过的链接
:visited        将特殊的样式添加到被访问过的链接
:first-child    将特殊的样式添加到元素的第一个子元素
:lang           允许创作者来定义指定的元素中使用的语言
2. 伪元素种类
:first-letter   将特殊的样式添加到文本的首字母
:first-line     将特殊的样式添加到文本的首行
:before         在某元素之前插入某些内容
:after          在某元素之后插入某些内容
tips:
- 伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到;
- 伪元素和伪类之所以这么容易混淆，是因为他们的效果类似而且写法相仿，但实际上 css3 为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示,   但因为兼容性的问题，所以现在大部分还是统一的单冒号，但是抛开兼容性的问题，我们在书写时应该尽可能养成好习惯，区分两者

#### 3. call() apply()



## js代码题
#### 1. 综合考察js题
- [详细](http://www.cnblogs.com/xxcanghai/p/5189353.html)
```
function Foo() {
    getName = function () { alert (1); };
    return this;
}
Foo.getName = function () { alert (2);};
Foo.prototype.getName = function () { alert (3);};
var getName = function () { alert (4);};
function getName() { alert (5);}

//请写出以下输出结果：
Foo.getName();       //2
getName();           //4
Foo().getName();     //1
getName();           //1
new Foo.getName();   //2
new Foo().getName(); //3
new new Foo().getName();  //3
```

#### 2. 经典JS闭包面试题
- [详细](http://www.cnblogs.com/xxcanghai/p/4991870.html)
```
function fun(n,o) {
  console.log(o)
  return {
    fun:function(m){
      return fun(m,n);
    }
  };
}
var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?
var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?
var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?

//a: undefined,0,0,0
//b: undefined,0,1,2
//c: undefined,0,1,1
```

#### 3. 连等符号
- [详细](http://www.iteye.com/topic/785445)
```
// a
var a = {n:1};  
a.x = a = {n:2};  
alert(a.x);  // --> undefined 

// b
var a = {n:1};  
var b = a;  // 持有a，以回查  
a.x = a = {n:2};  
alert(a.x);   // --> undefined  
alert(b.x);   // --> [object Object]  

// c
function fun(){  
    var a = b = 5;  
}  
fun();  
alert(typeof a);   // --> undefined  
alert(typeof b);   // --> number  
```

#### 4. 闭包
```
function Foo() {
    var i = 0;
    return function() {
        console.log(i++);
    }
}
 
var f1 = Foo(),
    f2 = Foo();
f1();   //0
f1();   //1
f2();   //0
```

#### 5. 布尔类型
```
console.log(([])?true:false);          //t
console.log(([]==false?true:false));   //t
console.log(({}==false)?true:false);   //f
tips：
1. 布尔类型里只有以下参数返回false，其它都为true：
Boolean(undefined)
Boolean(null)
Boolean(0)
Boolean(NaN)
Boolean('')

2. 布尔类型与其它任何类型进行比较，布尔类型会转换为number类型：
Number([]) => 0
Number转换类型的参数如果为对象返回的就是NaN
```

#### 6. 原型
```
var A = {n: 4399};
var B = function(){this.n = 9999;};
var C = function(){var n = 8888;};
B.prototype = A;
C.prototype = A;
var b = new B();
var c = new C();
A.n++;
console.log(b.n);   // 9999
console.log(c.n);   // 4400

tips:
new运算的具体执行过程：
1)创建一个空对象
2)把这个空对象的__proto__指向构造函数的prototype
3)把这个空对象赋值给this
4)执行构造函数内的代码，注意此时的this指向新对象，this.n=9999 等价于b.n=9999;
然后访问b.n，存在，直接输出b.n。
再去访问c.n，不存在，通过原型链__proto__向上寻找，c.__proto__指向C.prototype也就是A，所以就是输出A.n
```

## 网站
1. [小小沧海2016十家公司面试小记](http://www.cnblogs.com/xxcanghai/p/5205998.html)
2. 
